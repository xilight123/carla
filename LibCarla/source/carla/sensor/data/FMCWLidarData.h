// Copyright (c) 2020 Computer Vision Center (CVC) at the Universitat Autonoma
// de Barcelona (UAB).
//
// This work is licensed under the terms of the MIT license.
// For a copy, see <https://opensource.org/licenses/MIT>.

#pragma once

#include "carla/rpc/Location.h"

#include <cstdint>
#include <vector>
#include <numeric>

namespace carla {
namespace sensor {

namespace s11n {
  class FMCWLidarSerializer;
  class FMCWLidarHeaderView;
}

namespace data {

  /// Helper class to store and serialize the data generated by a RawLidar.
  ///
  /// The header of a Lidar measurement consists of an array of uint32_t's in
  /// the following layout
  ///
  ///    {
  ///      Horizontal angle (float),
  ///      Channel count,
  ///      Point count of channel 0,
  ///      ...
  ///      Point count of channel n,
  ///    }
  ///
  /// The points are stored in an array of detections, each detection consist in
  /// four floats, the point detected and the angle between the casted ray and
  /// the normal of the hitted object, and two unsigned integers, the index
  /// and the FMCW tag of the hitted object
  ///
  ///    {
  ///      X0, Y0, Z0, Cos(TH0), idx_0, tag_0
  ///      ...
  ///      Xn, Yn, Zn, Cos(THn), idx_n, tag_n
  ///    }
  ///

  #pragma pack(push, 1)
  class FMCWLidarDetection {
    public:
      geom::Location point{};
      uint32_t ring{};             // lidar ring
      uint32_t column{};           // lidar column
      float time{};                //
      float velocity{};            //
      uint32_t object_idx{};       // object ID
      uint32_t object_tag{};       // object Tag (class tag)
      // float object_x{};            // object velocity in lidar Coordinate system (velocity relative to background)
      // float object_y{};
      // float object_z{};

      float bbox_x{};             // 3d bbox center point location_x
      float bbox_y{};
      float bbox_z{};

      float bbox_w{};             // 3d bbox size_w
      float bbox_l{};
      float bbox_h{};

      // float self_x{};              // FMCW lidar velocity in lidar Coordinate system (velocity relative to background)
      // float self_y{};
      // float self_z{};

      float rotation_z{};

      FMCWLidarDetection() = default;

      FMCWLidarDetection(float x, float y, float z, uint32_t ring, uint32_t column,
                           float time, float velocity, uint32_t idx, uint32_t tag,
                          //  float object_x, float object_y, float object_z,
                           float bbox_x, float bbox_y, float bbox_z,
                           float bbox_w, float bbox_l, float bbox_h,
                          //  float self_x, float self_y, float self_z, 
                           float rotation_z) :

          point(x, y, z), ring{ring}, column{column},
          time{time}, velocity{velocity}, object_idx{idx}, object_tag{tag},
          // object_x{object_x}, object_y{object_y}, object_z{object_z},
          bbox_x{bbox_x}, bbox_y{bbox_y}, bbox_z{bbox_z},
          bbox_w{bbox_w}, bbox_l{bbox_l}, bbox_h{bbox_h},
          // self_x{self_x}, self_y{self_y}, self_z{self_z}, 
          rotation_z{rotation_z} { }

      FMCWLidarDetection(geom::Location p, uint32_t ring, uint32_t column,
                           float time, float velocity, uint32_t idx, uint32_t tag,
                          //  float object_x, float object_y, float object_z,
                           float bbox_x, float bbox_y, float bbox_z,
                           float bbox_w, float bbox_l, float bbox_h,
                          //  float self_x, float self_y, float self_z, 
                           float rotation_z) :

          point(p), ring{ring}, column{column},
          time{time}, velocity{velocity}, object_idx{idx}, object_tag{tag},
          // object_x{object_x}, object_y{object_y}, object_z{object_z},
          bbox_x{bbox_x}, bbox_y{bbox_y}, bbox_z{bbox_z},
          bbox_w{bbox_w}, bbox_l{bbox_l}, bbox_h{bbox_h},
          // self_x{self_x}, self_y{self_y}, self_z{self_z}, 
          rotation_z{rotation_z} { }

      void WritePlyHeaderInfo(std::ostream& out) const{
        out << "property float32 x\n" \
           "property float32 y\n" \
           "property float32 z\n" \
           "property uint32 ring\n" \
           "property uint32 column\n" \
           "property float32 time\n" \
           "property float32 velocity\n" \
           "property uint32 ObjIdx\n" \
           "property uint32 ObjTag\n" \

           "property float32 bbox_x\n" \
           "property float32 bbox_y\n" \
           "property float32 bbox_z\n" \

           "property float32 bbox_w\n" \
           "property float32 bbox_l\n" \
           "property float32 bbox_h\n" \

           "property float32 rotation_z\n"
           ;
      }

      void WriteDetection(std::ostream& out) const{
        out << point.x << ' ' << point.y << ' ' << point.z << ' ' \
          << ring << ' ' << column << ' ' << time << ' ' \
          << velocity << ' ' << object_idx << ' ' << object_tag << ' ' \
           
          << bbox_x << ' ' << bbox_y << ' ' << bbox_z << ' ' \
          << bbox_w << ' ' << bbox_l << ' ' << bbox_h << ' ' \
           
          << rotation_z;
      }
  };
  #pragma pack(pop)

  class FMCWLidarData {
    static_assert(sizeof(float) == sizeof(uint32_t), "Invalid float size");

  protected:
    enum Index : size_t {
      HorizontalAngle,
      ChannelCount,
      SIZE
    };

  public:
    explicit FMCWLidarData(uint32_t ChannelCount = 0u)
      : _header(Index::SIZE + ChannelCount, 0u) {
      _header[Index::ChannelCount] = ChannelCount;
    }

    FMCWLidarData &operator=(FMCWLidarData &&) = default;

    virtual ~FMCWLidarData() {}

    float GetHorizontalAngle() const {
      return reinterpret_cast<const float &>(_header[Index::HorizontalAngle]);
    }

    void SetHorizontalAngle(float angle) {
      std::memcpy(&_header[Index::HorizontalAngle], &angle, sizeof(uint32_t));
    }

    uint32_t GetChannelCount() const {
      return _header[Index::ChannelCount];
    }

    virtual void ResetMemory(std::vector<uint32_t> points_per_channel) {
      DEBUG_ASSERT(GetChannelCount() > points_per_channel.size());
      std::memset(_header.data() + Index::SIZE, 0, sizeof(uint32_t) * GetChannelCount());

      uint32_t total_points = static_cast<uint32_t>(
          std::accumulate(points_per_channel.begin(), points_per_channel.end(), 0));

      _ser_points.clear();
      _ser_points.reserve(total_points);
    }

    virtual void WriteChannelCount(std::vector<uint32_t> points_per_channel) {
      for (auto idxChannel = 0u; idxChannel < GetChannelCount(); ++idxChannel)
        _header[Index::SIZE + idxChannel] = points_per_channel[idxChannel];
    }

    virtual void WritePointSync(FMCWLidarDetection &detection) {
      _ser_points.emplace_back(detection);
    }

  protected:
    std::vector<uint32_t> _header;
    uint32_t _max_channel_points;

  private:
    std::vector<FMCWLidarDetection> _ser_points;

  friend class s11n::FMCWLidarHeaderView;
  friend class s11n::FMCWLidarSerializer;
  };

} // namespace s11n
} // namespace sensor
} // namespace carla
